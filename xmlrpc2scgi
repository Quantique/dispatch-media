#!/usr/bin/env python

# Copyright (C) 2005-2007, Glenn Washburn
#
# Refactoring - Copyright (c) 2010 The PyroScope Project <pyroscope.project@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# In addition, as a special exception, the copyright holders give
# permission to link the code of portions of this program with the
# OpenSSL library under certain conditions as described in each
# individual source file, and distribute linked combinations
# including the two.
#
# You must obey the GNU General Public License in all respects for
# all of the code used other than OpenSSL.  If you modify file(s)
# with this exception, you may extend this exception to your version
# of the file(s), but you are not obligated to do so.  If you do not
# wish to do so, delete this exception statement from your version.
# If you delete this exception statement from all source files in the
# program, then also delete it here.
#
# Contact:  Glenn Washburn <crass@berlios.de>
#
# Note that, before you contact the original author, this version of
# the module has undergone extensive refactoring.
#

"""
Run XMLRPC over SCGI.

./xmlrpc2scgi --endpoint 'ssh+unix://rtorrent.lan/~/var/run/rtorrent/rpc.socket' system.listMethods
./xmlrpc2scgi --endpoint 'ssh+unix://rtorrent.lan/~/var/run/rtorrent/rpc.socket' view_list
"""

import optparse
import pipes
import subprocess
import sys
import urlparse
import xmlrpclib
import yaml


# SCGI
def make_scgi_headers(headers):
    return ''.join(('%s\x00%s\x00' % t for t in headers))


def encode_netstring(string):
    return '%d:%s,' % (len(string), string)


def write_scgi(stream, data):
    """ Make an scgi request,
        see spec at: http://python.ca/scgi/protocol.txt
    """

    headers = make_scgi_headers((
        ('CONTENT_LENGTH', str(len(data))),
        ('SCGI', '1'),
    ))

    stream.write(encode_netstring(headers))
    stream.write(data)


# HTTP
def parse_http_headers(headers):
    """ Get header (key, value) pairs from header string.
    """

    return dict(line.rstrip().split(": ", 1)
        for line in headers.splitlines())


def parse_http(resp):
    # The response is plain HTTP not wrapped by SCGI,
    # which is only a request spec.
    # The headers are the bare xml-rpc requirements, hard-coded by rtorrent.
    # Always 200 OK; xml-rpc has its own error signaling.
    headers_str, content = resp.split("\r\n\r\n", 1)
    headers = parse_http_headers(headers_str)
    clen = int(headers['Content-Length'])

    # Just in case the transport is bogus.
    assert clen == len(content)

    return content



# Socket IO
SCHEME_TCP = 'tcp'
SCHEME_UNIX = 'unix'
SCHEME_SSH_UNIX = 'ssh+unix'
urlparse.uses_netloc.append(SCHEME_TCP)
urlparse.uses_netloc.append(SCHEME_SSH_UNIX)

# posix portable
NETCAT = '/bin/nc'


def cmd_of_endpoint(url):
    """ Parse urls used to reach the rtorrent SCGI socket.

        Currently allows unix sockets, local or via ssh, and tcp sockets.

        Unix domain sockets
            unix:/var/run/rtorrent.socket
            unix:rtorrent.socket
            /var/run/rtorrent.socket
            rtorrent.socket

        The unix scheme is the default for urls starting with a slash.

        Unix domain sockets, on a remote host accessed over SSH
            ssh+unix://host/var/run/rtorrent.socket
            ssh+unix://user@host/var/run/rtorrent.socket
            ssh+unix://user@host/~/rtorrent/socket
            ssh+unix://host:5022/var/run/rtorrent/socket

        The ssh syntax aims to be compatible with this internet draft:
            http://tools.ietf.org/html/draft-ietf-secsh-scp-sftp-ssh-uri
        A leading tilde can be used to refer to the home directory.

        TCP sockets
            tcp://host:port/

    """

    # pipes.quote is used because ssh always goes through a login shell.
    # The only exception is for redirecting ports, which can't be used
    # to access a domain socket.

    us = urlparse.urlsplit(url, SCHEME_UNIX, allow_fragments=False)
    path = us.path
    netloc = us.netloc

    if us.scheme == SCHEME_TCP:
        if url != urlparse.urlunsplit((SCHEME_TCP, netloc, '/', '', '')):
            raise ValueError(url)
        if netloc != '%s:%d' % (us.hostname, us.port):
            raise ValueError(url)
        cmd = [ NETCAT, '--', netloc ]
    elif us.scheme == SCHEME_UNIX:
        if url != urlparse.urlunsplit((SCHEME_UNIX, '', path, '', '')):
            raise ValueError(url)
        cmd = [ NETCAT, '-U', '--', path ]
    elif us.scheme == SCHEME_SSH_UNIX:
        if url != urlparse.urlunsplit((SCHEME_SSH_UNIX, netloc, path, '', '')):
            raise ValueError(url)
        if not path or not path.startswith('/'):
            raise ValueError(url)

        if path.startswith('/~/'):
            clean_path = '~/' + pipes.quote(path[3:])
        else:
            clean_path = pipes.quote(path)

        if us.username:
            # user@ takes priority on -l user
            ssh_netloc = '%s@%s' % (us.username, us.hostname)
        else:
            ssh_netloc = us.hostname

        if us.port:
            reconstructed_netloc = '%s:%d' % (ssh_netloc, us.port)
            port_flag = [ '-p', str(us.port) ]
        else:
            reconstructed_netloc = ssh_netloc
            port_flag = []

        if reconstructed_netloc != netloc:
            raise ValueError(url)

        cmd = [ 'ssh', '-T' ] + port_flag + [
            '--', netloc, NETCAT, '-U', '--', clean_path, ]
    else:
        raise ValueError(url)

    return cmd


def do_req_and_resp(endpoint, data):
    """ Open a transport, send an SCGI request, wait and grab reply.

        TODO: accept http endpoints as well, with none of the SCGI wrapping.
    """

    cmd = cmd_of_endpoint(endpoint)
    proc = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    # Can't use communicate:
    # that would close stdin, send a sighup, netcat would bail.
    write_scgi(proc.stdin, data)
    resp = proc.stdout.read()
    proc.stdin.close()
    proc.wait()

    if proc.returncode:
        raise subprocess.CalledProcessError(cmd, proc.returncode)

    return resp


def do_xmlrpc(endpoint, methodname, params=()):
    """ Send an xmlrpc request over scgi to endpoint.
        endpoint:   url of the scgi socket
        methodname: xmlrpc method name
        params:     tuple of simple python objects
        returns:    unmarshalled response
    """

    req_xml = xmlrpclib.dumps(params, methodname)
    #sys.stderr.write('req_xml: %s\n' % req_xml)
    resp_http = do_req_and_resp(endpoint, req_xml)
    resp_xml = parse_http(resp_http)

    # Yes, it's ok to unwrap the totally superfluous methodResponse.params
    # Faults were already turned into exceptions.
    resp = xmlrpclib.loads(resp_xml)[0][0]

    return resp


def convert_params_to_native(params):
    """ Parse xmlrpc-c command line arg syntax.

        Arguments are strings, unless prefixed by b/ i/ s/
        In which case, they are bools, integers, or strings.
        s/ should be used if a string may contain a slash.
    """

    cparams = []
    for param in params:
        if len(param) < 2 or param[1] != '/':
            cparams.append(param)
            continue

        if param[0] == 'i':
            ptype = int
        elif param[0] == 'b':
            ptype = bool
        elif param[0] == 's':
            ptype = str
        else:
            cparams.append(param)
            continue

        cparams.append(ptype(param[2:]))

    return tuple(cparams)


def main():
    """ Command line handler.
    """

    parser = optparse.OptionParser()
    parser.add_option('--endpoint', dest='endpoint')
    opts, args = parser.parse_args()

    if not opts.endpoint:
        raise RuntimeError('An endpoint is mandatory')
    if not args:
        raise RuntimeError('No command given')

    methodname = args.pop(0)
    resp = do_xmlrpc(
        opts.endpoint, methodname, convert_params_to_native(args))
    yaml.dump(resp, sys.stdout, Dumper=yaml.CSafeDumper,
            explicit_end=False,
            default_flow_style=False)


if __name__ == "__main__":
    main()



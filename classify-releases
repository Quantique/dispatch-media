#!/usr/bin/python
# vim: set fileencoding=utf-8 : -*- coding: utf-8 -*
# Copyright 2010 Quantique. Licence: GPL3+
# ~/bin/classify-releases


"""
Classify scene releases.

Usage:
    classify-releases  --dirs     directory…
    classify-releases  --torrents release.torrent…
    classify-releases  --archives archive.rar…
    classify-releases [--auto]    (directory|torrent|archive)…

Dependencies:
- python-libtorrent (reading .torrent files)
- python-yaml (output)
- p7zip-full (listing many archives)
- p7zip-rar (listing rar archives)

Supported categories:
- Album
- Comics
- Discography
- EBook
- Font
- Iso
- Movie
- PC
- PS2
- PS3
- Series
- Wii
- XBox
Special categories:
- Archive
- Empty
- Unknown

Good categories should be widely used and detectable reliably.

When reporting bugs or possible enhancements, such as a miscategorisation
that could be prevented, include debug output (-vv) and a torrent file
or a listing.

TODO:
    Specialized extractors
        MusicBrainz
        IMDB
        NFO

"""

from dispatchmedia.torrents import TorrentFileError
from dispatchmedia.classify import Release, Torrent, Directory, Archive, UnknownReleaseKindError, classify

import codecs
import collections
import locale
import logging
import optparse
import os.path
import subprocess
import sys
import yaml

LOGGER = logging.getLogger(__name__)

def main():
    # Unbreak stdio encodings. is_unicode will be used by YAML.
    locale.setlocale(locale.LC_ALL, '')
    encoding = locale.getpreferredencoding(False)
    sys.stdout = codecs.getwriter(encoding)(sys.stdout)
    sys.stderr = codecs.getwriter(encoding)(sys.stderr)
    is_unicode = encoding.lower().startswith('utf')

    parser = optparse.OptionParser()
    parser.add_option('--dirs',
            action='store_const', dest='kind', const=Directory,
            help='Classify directories.',
            )
    parser.add_option('--archives',
            action='store_const', dest='kind', const=Archive,
            help='Classify archives.',
            )
    parser.add_option('--torrents',
            action='store_const', dest='kind', const=Torrent,
            help='Classify torrents.',
            )
    parser.add_option('--auto',
            action='store_const', dest='kind', const=None,
            help='Classify any supported type, by extension.'
                ' This is the default.',
            )
    parser.add_option('--group',
            action='store_true', dest='group',
            help='Group output by category.',
            )
    parser.add_option('-v', '--verbose',
            action='count',
            dest='verbosity',
            default=0,
            help='Increase verbosity',
            )

    (options, args) = parser.parse_args()

    # WARNING, INFO, DEBUG
    log_level = logging.WARNING - 10 * options.verbosity
    logging.basicConfig(level=log_level, format='%(levelname)s: %(message)s')

    if not args:
        parser.print_help()
        return 2

    groups = collections.defaultdict(list)

    for fname in args:
        fname = fname.decode(encoding)
        try:
            if options.kind is None:
                rlz = Release.from_fname(fname)
            else:
                rlz = options.kind(fname)
            cat = classify(rlz).name()
        except subprocess.CalledProcessError, e:
            LOGGER.warn(e)
            continue
        except TorrentFileError, e:
            LOGGER.warn(e)
            continue
        except UnknownReleaseKindError, e:
            LOGGER.warn(e)
            LOGGER.info(
                'You can use command-line flags to specify the release type')
            continue

        if options.group:
            groups[cat].append(fname)
        else:
            yaml.safe_dump({fname: cat}, sys.stdout,
                    default_flow_style=False, allow_unicode=is_unicode)

    if options.group:
        yaml.safe_dump(dict(groups), sys.stdout,
                default_flow_style=False, allow_unicode=is_unicode)

if __name__ == '__main__':
    sys.exit(main())


